/******************************************************************************
 *                                  LICENSE                                   *
 ******************************************************************************
 *  This file is part of vrmit.                                               *
 *                                                                            *
 *  vrmit is free software: you can redistribute it and/or modify             *
 *  it under the terms of the GNU General Public License as published by      *
 *  the Free Software Foundation, either version 3 of the License, or         *
 *  (at your option) any later version.                                       *
 *                                                                            *
 *  vrmit is distributed in the hope that it will be useful,                  *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
 *  GNU General Public License for more details.                              *
 *                                                                            *
 *  You should have received a copy of the GNU General Public License         *
 *  along with vrmit.  If not, see <https://www.gnu.org/licenses/>.           *
 ******************************************************************************
 *  Purpose:                                                                  *
 *      Provides the RK4 integrator and electromagnetic force.                *
 ******************************************************************************
 *  Author:     Ryan Maguire                                                  *
 *  Date:       June 19, 2025                                                 *
 ******************************************************************************/

/*  sqrt found here, used for the Coulomb force.                              */
#include <math.h>

/*  Function prototypes, and typedefs for force, Vec2, and Vec4.              */
#include "rk4.h"

/******************************************************************************
 *  Function:                                                                 *
 *      coulomb                                                               *
 *  Purpose:                                                                  *
 *      Computes the Coulomb force on a particle in the plane. It is assumed  *
 *      the force is generated by a point source at the origin, and that both *
 *      have positive unit charge. Units are made so that the Coulomb         *
 *      constant is 1 as well, k = 1.                                         *
 *  Arguments:                                                                *
 *      position (const Vec2 * const):                                        *
 *          The point in the plane where the second charge lies.              *
 *  Output:                                                                   *
 *      out (Vec2):                                                           *
 *          The force exterted on the point by the charge at the origin.      *
 ******************************************************************************/
Vec2 coulomb(const Vec2 * const position)
{
    /*  Variable for the output force.                                        */
    Vec2 out;

    /*  The square of the Euclidean norm of the point in the plane.           */
    const double rsq = position->x * position->x + position->y * position->y;

    /*  The L2 norm, given by Pythagoras, || P || = sqrt(x^2 + y^2).          */
    const double r = sqrt(rsq);

    /*  The input vector is not necessary a unit vector. The inverse square   *
     *  law thus becomes:                                                     *
     *                                                                        *
     *             ^          ->                                              *
     *             R          R                                               *
     *      F = -------- = --------                                           *
     *                 2          3                                           *
     *          || R ||    || R ||                                            *
     *                                                                        *
     *  Where the "hat" indicates the unit vector in the direction of R. The  *
     *  scale factor is hence the reciprocal of the cube of the norm.         */
    const double scale = 1.0 / (r * rsq);

    /*  The force is just the scale factor times the position vector. Compute.*/
    out.x = position->x * scale;
    out.y = position->y * scale;

    return out;
}
/*  End of coulomb.                                                           */

/******************************************************************************
 *  Function:                                                                 *
 *      rk4_factor                                                            *
 *  Purpose:                                                                  *
 *      Computes the perturbation factors for the phase-space version of RK4. *
 *      The increment in RK4 is given by a linear combination of 4 points in  *
 *      phase space, each of which has a similar formula. This function       *
 *      calculates the locations of these points.                             *
 *  Arguments:                                                                *
 *      u0 (const Vec4 * const):                                              *
 *          The current location of the point for the ODE.                    *
 *      h (double):                                                           *
 *          The step size used in RK4.                                        *
 *      u1 (const Vec4 * const):                                              *
 *          The perturbation point, these are the k_n's in the RK4 method.    *
 *      f (force):                                                            *
 *          The force on the particle. We use Newton's 2nd law and apply RK4  *
 *          to find the path of the particle.                                 *
 *  Output:                                                                   *
 *      out (Vec4):                                                           *
 *          The new perturbation factor, one of the k_n terms.                *
 ******************************************************************************/
Vec4 rk4_factor(const Vec4 * const u0, double h, const Vec4 * const u1, force f)
{
    /*  Declare a variable for the output.                                    */
    Vec4 out;

    /*  Place holder for the Euler-like step used to compute out.p and out.v. */
    Vec2 p;

    /*  u1 acts like the velocity in phase-space, and u0 is the position.     *
     *  Calculate the new point by applying Euler's method.                   */
    p.x = u0->p.x + h * u1->p.x;
    p.y = u0->p.y + h * u1->p.y;

    /*  Same idea, but for the velocity component in phase-space. Here, u1    *
     *  acts as acceleration, and u0 acts as velocity. Update.                */
    out.p.x = u0->v.x + h * u1->v.x;
    out.p.y = u0->v.y + h * u1->v.y;

    /*  The new velocity is given by the force at the current point. Compute. */
    out.v = f(&p);

    return out;
}
/*  End of rk4_factor.                                                        */

/******************************************************************************
 *  Function:                                                                 *
 *      rk4                                                                   *
 *  Purpose:                                                                  *
 *      Performs RK4 to numerical solve an ODE.                               *
 *  Arguments:                                                                *
 *      f (force):                                                            *
 *          The force on the particle. We use Newton's 2nd law and apply RK4  *
 *          to find the path of the particle.                                 *
 *      u (Vec4 * const):                                                     *
 *          The initial position and velocity of the particle.                *
 *      h (double):                                                           *
 *          The step size.                                                    *
 *      steps (size_t):                                                       *
 *          The number of steps to perform.                                   *
 *  Output:                                                                   *
 *      None (void).                                                          *
 ******************************************************************************/
void rk4(force f, Vec4 * const u, double h, size_t steps)
{
    /*  Index for keeping track of the number of iterations performed.        */
    size_t n = 0;

    /*  Constant multiples of h used in the computation.                      */
    const double h0 = 0.5 * h;
    const double h1 = h * 0.1666666666666667;

    /*  Current acceleration vector given by the starting position.           */
    Vec2 a = f(&u->p);

    /*  Compute the initial Runge-Kutta factors.                              */
    Vec4 k1 = {u->v, a};
    Vec4 k2 = rk4_factor(u, h0, &k1, f);
    Vec4 k3 = rk4_factor(u, h0, &k2, f);
    Vec4 k4 = rk4_factor(u, h, &k2, f);

    /*  Iteratively performed RK4.                                            */
    for (n = 0; n < steps; ++n)
    {
        /*  We numerically solve d^2/dt^2 p = F(p) in two steps. First we     *
         *  compute the velocity dp/dt, meaning we solve dv/dt = F(p). We     *
         *  solve numerically with the Runge-Kutta method. We use this v to   *
         *  compute p via dp/dt = v, solving numerically again. So long as dt *
         *  is small, the error should be small as well. Error is O(dt^4).    */
        u->p.x += h1 * (k1.p.x + 2.0*k2.p.x + 2.0*k3.p.x + k4.p.x);
        u->p.y += h1 * (k1.p.y + 2.0*k2.p.y + 2.0*k3.p.y + k4.p.y);

        /*  Velocity component of the RK4 update.                             */
        u->v.x += h1 * (k1.v.x + 2.0*k2.v.x + 2.0*k3.v.x + k4.v.x);
        u->v.y += h1 * (k1.v.y + 2.0*k2.v.y + 2.0*k3.v.y + k4.v.y);

        /*  Update the Runge-Kutta factors.                                   */
        a = f(&u->p);

        k1.p = u->v;
        k1.v = a;

        k2 = rk4_factor(u, h0, &k1, f);
        k3 = rk4_factor(u, h0, &k2, f);
        k4 = rk4_factor(u, h, &k2, f);
    }
}
/*  End of rk4.                                                               */

/******************************************************************************
 *  Function:                                                                 *
 *      integrate                                                             *
 *  Purpose:                                                                  *
 *      Given a set of data points, performs RK4 on all of them.              *
 *  Arguments:                                                                *
 *      f (force):                                                            *
 *          The force on the particle. We use Newton's 2nd law and apply RK4  *
 *          to find the path of the particle.                                 *
 *      u (Vec4 * const):                                                     *
 *          Array with the initial positions and velocities of the particles. *
 *      n_elements (size_t):                                                  *
 *          The number of elements in the "u" array.                          *
 *      h (double):                                                           *
 *          The step size.                                                    *
 *      steps (size_t):                                                       *
 *          The number of steps to perform.                                   *
 *  Output:                                                                   *
 *      None (void).                                                          *
 ******************************************************************************/
void
integrate(force f, Vec4 * const u, size_t n_elements, double h, size_t steps)
{
    /*  Variable for indexing over the array.                                 */
    size_t n;

    /*  Loop through each point and apply RK4.                                */
    for (n = 0; n < n_elements; ++n)
        rk4(f, &u[n], h, steps);
}
/*  End of integrate.                                                         */
